package com.daoshan.school.demo.java_23_design_mode.create_modes.factory_mode.main;

import com.daoshan.school.demo.java_23_design_mode.create_modes.factory_mode.classer.AmdFactory;
import com.daoshan.school.demo.java_23_design_mode.create_modes.factory_mode.engineer.AbstractFactoryComputerEngineer;
import com.daoshan.school.demo.java_23_design_mode.create_modes.factory_mode.factory.AbstractFactory;

/**
 * java-设计模式   简单工厂设计模式(按照产品结构来划分工厂)
 *
 * 举个生活中常见的例子——组装电脑，我们在组装电脑的时候，通常需要选择一系列的配件，比如CPU、硬盘、内存、主板、电源、机箱等。
 * 为讨论使用简单点，只考虑选择CPU和主板的问题。
 *
 *　　事实上，在选择CPU的时候，面临一系列的问题，比如品牌、型号、针脚数目、主频等问题，只有把这些问题都确定下来，才能确定具体的CPU。
 *
 *　　同样，在选择主板的时候，也有一系列问题，比如品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。
 *
 *　　选择不同的CPU和主板，是每个客户在组装电脑的时候，向装机公司提出的要求，也就是我们每个人自己拟定的装机方案。
 *
 *　在最终确定这个装机方案之前，还需要整体考虑各个配件之间的兼容性。比如：CPU和主板，如果使用Intel的CPU和AMD的主板是根本无法组装的。
 * 因为Intel的CPU针脚数与AMD主板提供的CPU插口不兼容，就是说如果使用Intel的CPU根本就插不到AMD的主板中，所以装机方案是整体性的，
 * 里面选择的各个配件之间是有关联的。
 *
 *　对于装机工程师而言，他只知道组装一台电脑，需要相应的配件，但是具体使用什么样的配件，还得由客户说了算。也就是说装机工程师只是负责组装，
 * 而客户负责选择装配所需要的具体的配件。因此，当装机工程师为不同的客户组装电脑时，只需要根据客户的装机方案，去获取相应的配件，然后组装即可。
 */
public class main {

    /*public static void main(String[] args) {
        ComputerEngineer cf = new ComputerEngineer();
        cf.makeComputer(1,2);
    }
}*/
/**
 * 　上面的实现，虽然通过简单工厂方法解决了：对于装机工程师，只知CPU和主板的接口，而不知道具体实现的问题。
 * 但还有一个问题没有解决，那就是这些CPU对象和主板对象其实是有关系的，需要相互匹配的。而上面的实现中，
 * 并没有维护这种关联关系，CPU和主板是由客户任意选择，这是有问题的。比如在客户端调用makeComputer时，
 * 传入参数为(1,2)，针脚数和插槽数不一样
 *
 *
 *
 *
 *
 *
 *
 *
 * 引进抽象工厂模式
 *
 * 　每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，
 *   工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。
 *
 *　　在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。
 *
 *　　所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。
 * 比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。
 * 而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，
 *　显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，
 * 形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。
 * 只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。
 *
 *　上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，
 * 就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，
 * 会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，
 * 工厂方法模式所给出的工厂等级结构的数目也会随之增加。
 *
 *
 * 抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广。
 *
 *　　假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。
 * 那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。
 * 这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。
 *　通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。
 *
 *
 *  在什么情况下应当使用抽象工厂模式
 *　　1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。
 *
 *　2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
 *
 *　3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组）
 *
 *　4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。
 *
 *  抽象工厂模式的起源
 *　　抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。
 *
 *　在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。
 *
 *
 *  抽象工厂模式的优点
 * 分离接口和实现
 *　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。
 *
 * 使切换产品族变得容易
 *　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。
 *
 * 抽象工厂模式的缺点
 * 不太容易扩展新的产品
 *　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。
 *
 */
        //抽象工厂模式
        public static void main(String[]args){

            AbstractFactory factory = new AmdFactory();
            AbstractFactoryComputerEngineer cf = new AbstractFactoryComputerEngineer();
            cf.makeComputer(factory);
        }
}